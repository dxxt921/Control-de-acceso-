================================================================================
         OBJETOS DE BASE DE DATOS - ENTREGABLE 3
         Sistema de Control de Acceso IoT
         Base de datos: smart_access_db (MySQL)
================================================================================


1. TABLA DE AUDITORÍA (access_audit_log)
--------------------------------------------------------------------------------
Descripción: Tabla donde se almacenan los registros de auditoría de cada acceso
detectado por el sistema. Cada vez que un usuario pasa su tarjeta NFC y el
registro se inserta en la tabla access_logs, esta tabla recibe automáticamente
una copia con información adicional como el tipo de acción, una descripción
legible y la marca de tiempo de la auditoría. Esta tabla es llenada
automáticamente por el trigger a través del stored procedure.

CREATE TABLE access_audit_log (
    audit_id INT AUTO_INCREMENT PRIMARY KEY,
    action_type VARCHAR(20) NOT NULL,
    uid_detected VARCHAR(50) NOT NULL,
    access_granted BOOLEAN NOT NULL,
    station_id INT,
    original_timestamp DATETIME NOT NULL,
    audit_timestamp DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    audit_description VARCHAR(255)
);


2. STORED PROCEDURE: sp_registrar_auditoria
--------------------------------------------------------------------------------
Descripción: Procedimiento almacenado que recibe los datos de un acceso
(UID, resultado, estación y marca de tiempo) y los inserta en la tabla de
auditoría access_audit_log. Este procedimiento NO se ejecuta manualmente,
sino que es llamado automáticamente por el trigger trg_after_access_insert
cada vez que se inserta un nuevo registro en access_logs.

Parámetros de entrada:
  - p_uid: Identificador único de la tarjeta NFC detectada
  - p_access_granted: Si el acceso fue concedido (TRUE) o denegado (FALSE)
  - p_station_id: Identificador de la estación de acceso
  - p_timestamp: Marca de tiempo del acceso original

CREATE PROCEDURE sp_registrar_auditoria(
    IN p_uid VARCHAR(50),
    IN p_access_granted BOOLEAN,
    IN p_station_id INT,
    IN p_timestamp DATETIME
)
BEGIN
    INSERT INTO access_audit_log (
        action_type, uid_detected, access_granted, station_id,
        original_timestamp, audit_timestamp, audit_description
    ) VALUES (
        'INSERT', p_uid, p_access_granted, p_station_id, p_timestamp, NOW(),
        CONCAT('Acceso registrado - UID: ', p_uid,
               ' - Resultado: ', IF(p_access_granted, 'CONCEDIDO', 'DENEGADO'))
    );
END


3. TRIGGER: trg_after_access_insert
--------------------------------------------------------------------------------
Descripción: Disparador que se ejecuta automáticamente DESPUÉS de cada
INSERT en la tabla access_logs. Su función es llamar al procedimiento
almacenado sp_registrar_auditoria, pasándole los datos del nuevo registro
insertado (usando la referencia NEW). De esta forma, cada vez que el proceso
batch inserta registros de acceso en la base de datos, el trigger se encarga
de generar la auditoría correspondiente de manera automática y transparente.

CREATE TRIGGER trg_after_access_insert
AFTER INSERT ON access_logs
FOR EACH ROW
BEGIN
    CALL sp_registrar_auditoria(
        NEW.uid_detected,
        NEW.access_granted,
        NEW.station_id,
        NEW.access_timestamp
    );
END


4. STORED PROCEDURE: sp_backup_access_logs
--------------------------------------------------------------------------------
Descripción: Procedimiento almacenado que realiza un backup REAL de todos
los registros de la tabla access_logs. A diferencia de simplemente copiar
datos a otra tabla, este procedimiento exporta la información completa a un
archivo CSV físico en el disco del servidor, utilizando la instrucción
SELECT INTO OUTFILE de MySQL. El archivo se genera con un nombre único que
incluye la fecha y hora de ejecución, y se almacena en el directorio de
uploads de MySQL (C:/ProgramData/MySQL/MySQL Server 9.1/Uploads/).

El archivo CSV generado incluye encabezados (ID, UID, FECHA_ACCESO,
ACCESO_CONCEDIDO, ESTACION) y los campos están separados por comas y
opcionalmente encerrados entre comillas dobles.

Este procedimiento es llamado automáticamente por el EVENT evt_backup_diario
a las 22:30 horas, pero también puede ejecutarse manualmente con:
CALL sp_backup_access_logs();

CREATE PROCEDURE sp_backup_access_logs()
BEGIN
    DECLARE v_count INT DEFAULT 0;
    DECLARE v_archivo VARCHAR(255);

    SELECT COUNT(*) INTO v_count FROM access_logs;

    IF v_count > 0 THEN
        SET v_archivo = CONCAT('C:/ProgramData/MySQL/MySQL Server 9.1/Uploads/backup_access_logs_',
                               DATE_FORMAT(NOW(), '%Y%m%d_%H%i%s'), '.csv');

        SET @sql_backup = CONCAT(
            "SELECT 'ID','UID','FECHA_ACCESO','ACCESO_CONCEDIDO','ESTACION' ",
            "UNION ALL ",
            "SELECT CAST(id AS CHAR), uid_detected, CAST(access_timestamp AS CHAR), ",
            "CAST(access_granted AS CHAR), CAST(station_id AS CHAR) ",
            "FROM access_logs ",
            "INTO OUTFILE '", v_archivo, "' ",
            "FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' ",
            "LINES TERMINATED BY '\\n'"
        );

        PREPARE stmt FROM @sql_backup;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
    END IF;

    SELECT v_count AS registros_respaldados,
           v_archivo AS archivo_generado,
           NOW() AS fecha_ejecucion,
           'BACKUP REAL - Archivo CSV generado en disco' AS mensaje;
END


5. STORED PROCEDURE: sp_daily_stats
--------------------------------------------------------------------------------
Descripción: Procedimiento almacenado que genera un reporte estadístico de
los accesos del día actual. Retorna el total de accesos, cuántos fueron
concedidos, cuántos denegados, la cantidad de usuarios únicos que accedieron,
y las marcas de tiempo del primer y último acceso del día. Este procedimiento
se puede ejecutar manualmente con: CALL sp_daily_stats();

CREATE PROCEDURE sp_daily_stats()
BEGIN
    SELECT
        COUNT(*) AS total_accesos,
        SUM(CASE WHEN access_granted = TRUE THEN 1 ELSE 0 END) AS accesos_concedidos,
        SUM(CASE WHEN access_granted = FALSE THEN 1 ELSE 0 END) AS accesos_denegados,
        COUNT(DISTINCT uid_detected) AS usuarios_unicos,
        MIN(access_timestamp) AS primer_acceso,
        MAX(access_timestamp) AS ultimo_acceso,
        CURDATE() AS fecha_consulta
    FROM access_logs
    WHERE DATE(access_timestamp) = CURDATE();
END


6. EVENT: evt_backup_diario (Disparador Programado)
--------------------------------------------------------------------------------
Descripción: Evento programado de MySQL que se ejecuta automáticamente todos
los días a las 22:30 horas (10:30 PM). Este horario fue elegido porque el
proceso batch del sistema se ejecuta a las 22:00 horas (10:00 PM), por lo
que el backup se realiza 30 minutos después, asegurando que todos los
registros del día ya fueron procesados e insertados en la base de datos.

El EVENT llama al procedimiento almacenado sp_backup_access_logs, el cual
genera un archivo CSV real en disco con todos los registros de acceso.

Requisito previo: El Event Scheduler de MySQL debe estar habilitado con:
SET GLOBAL event_scheduler = ON;

CREATE EVENT evt_backup_diario
ON SCHEDULE EVERY 1 DAY
STARTS CONCAT(CURDATE(), ' 22:30:00')
COMMENT 'Backup REAL automático - 30 min después del batch'
DO
BEGIN
    CALL sp_backup_access_logs();
END


================================================================================
FLUJO COMPLETO DEL SISTEMA
================================================================================

Tag NFC → Arduino → Puerto Serial → Java Spring Boot → Archivo CSV
                                          ↓
                                   Proceso Batch (22:00 hrs)
                                          ↓
                                   INSERT en access_logs
                                          ↓
                                   TRIGGER (trg_after_access_insert)
                                          ↓
                                   CALL sp_registrar_auditoria()
                                          ↓
                                   INSERT en access_audit_log (auditoría)

                                   EVENT (22:30 hrs - evt_backup_diario)
                                          ↓
                                   CALL sp_backup_access_logs()
                                          ↓
                                   SELECT INTO OUTFILE → archivo .csv en disco
                                   (C:/ProgramData/MySQL/MySQL Server 9.1/Uploads/)

================================================================================
COMANDOS DE VERIFICACIÓN
================================================================================

-- Ver que el trigger existe:
SHOW TRIGGERS FROM smart_access_db;

-- Ver los stored procedures:
SHOW PROCEDURE STATUS WHERE Db = 'smart_access_db';

-- Ver el EVENT programado:
SHOW EVENTS FROM smart_access_db;

-- Ver registros de auditoría:
SELECT * FROM access_audit_log;

-- Ejecutar backup manualmente:
CALL sp_backup_access_logs();

-- Ver estadísticas del día:
CALL sp_daily_stats();

-- Verificar que el Event Scheduler está activo:
SHOW VARIABLES LIKE 'event_scheduler';
